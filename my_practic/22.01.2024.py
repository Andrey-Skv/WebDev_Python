"""
Ваша задача - создать функцию, которая может принимать любое неотрицательное целое число в качестве аргумента
и возвращать его с его цифрами в порядке убывания. По сути, переставьте цифры,
чтобы получить максимально возможное число.

Примеры:
Ввод: 42145 Вывод: 54421
Ввод: 145263 Вывод: 654321
Ввод: 123456789 Вывод: 987654321

"""

# num = 1235944995554
# res = int(''.join(sorted(list(str(num)), reverse=True)))
# print(res)


"""
Вам будет дано слово. Ваша задача - вернуть средний символ слова. Если длина слова нечетная, верните средний символ.
Если длина слова четная, верните 2 средних символа.

#Примеры:
Kata.getMiddle("test") should return "es"
Kata.getMiddle("testing") should return "t"
Kata.getMiddle("middle") should return "dd"
Kata.getMiddle("A") should return "A"
#Ввод

Слово (строка) длины 0 < str < 1000 
"""
# text = 'weatkjz5g;jet'
# res = text[len(text)//2-1:len(text)//2+1] if len(text) % 2 == 0 else text[len(text)//2]
# print(res)

"""
Вы создадите функцию, которая принимает список неотрицательных целых чисел и строк
и возвращает новый список с отфильтрованными строками.
Пример
filter_list([1,2,'a','b']) == [1,2]
filter_list([1,'a','b',0,15]) == [1,0,15]
filter_list([1,2,'aasf','1','123',123]) == [1,2,123]
"""
# filter_list = [1, 2, 'aasf', '1', '123', 123]
# new_list = [elem for elem in filter_list if isinstance(elem, int)]
# print(new_list)

"""
Учитывая массив целых чисел, найдите то, которое появляется нечетное количество раз.
Всегда будет только одно целое число, которое появляется нечетное количество раз.
Примеры
[7] должно вернуться 7, потому что это происходит 1 раз (что странно).
[0] должно вернуться 0, потому что это происходит 1 раз (что странно).
[1,1,2] должно вернуться 2, потому что это происходит 1 раз (что странно).
[0,1,0,1,0] должно вернуться 0, потому что это происходит 3 раза (что странно).
[1,2,2,3,3,3,4,3,3,3,2,2,1] должно вернуться 4, потому что оно появляется 1 раз (что странно).
"""

# seq = [20, 1, -1, 2, -2, 3, 3, 5, 5, 1, 2, 4, 20, 4, -1, -2, 5]
# for elem in seq:
#     if not seq.count(elem) % 2 == 0:
#         print(elem)
#         break

"""
Даны два массива строк a1 и a2 возвращают отсортированный массив r в лексикографическом порядке строк a1, 
которые являются подстроками строк a2.

Пример 1:
a1 = ["arp", "live", "strong"]
a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

ВОЗВРАТ ["arp", "live", "strong"]
Пример 2:
a1 = ["tarp", "mice", "bull"]
a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

ВОЗВРАТ []
"""
# a1 = ["arp", "mice", "bull", "arp"]
# a2 = ["lively", "alive", "harp", "sharp", "armstrong"]
# new_list = []
# for elem in a1:
#     for item in a2:
#         if elem in item and elem not in new_list:
#             new_list.append(elem)
#             break
# print(sorted(new_list))
#
#
# # другое решение
# def in_array(a1, a2):
#     return sorted({elem for elem in a1 if any(elem in s for s in a2)})
#     # внутри листа собирается еще один лист с которым сравнивается
#
#
# print(in_array(a1, a2))

"""
Напишите функцию, persistence которая принимает положительный параметр num
и возвращает его мультипликативную персистентность, то есть количество раз,
в которое вы должны перемножать цифры, num пока не получите однозначную цифру.

Например, (Ввод --> Вывод):

39 --> 3 (because 3*9 = 27, 2*7 = 14, 1*4 = 4 and 4 has only one digit)
999 --> 4 (because 9*9*9 = 729, 7*2*9 = 126, 1*2*6 = 12, and finally 1*2 = 2)
4 --> 0 (because 4 is already a one-digit number)
"""
# n = 4
# my_list = list(str(n))
# count = 0
# res = 1
# while len(my_list) > 1:
#     for i in my_list:
#         res = int(i) * res
#     my_list = list(str(res))
#     res = 1
#     count += 1
# print(count)

